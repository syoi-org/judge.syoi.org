// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/syoi-org/judy/ent"
	"github.com/syoi-org/judy/ent/judge"
	"github.com/syoi-org/judy/ent/problem"
	"github.com/syoi-org/judy/ent/submission"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateJudge handles POST /judges requests.
func (h *OgentHandler) CreateJudge(ctx context.Context, req *CreateJudgeReq) (CreateJudgeRes, error) {
	b := h.client.Judge.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	b.SetName(req.Name)
	b.SetCode(req.Code)
	b.SetType(judge.Type(req.Type))
	b.SetConfiguration(req.Configuration)
	// Add all edges.
	b.AddProblemIDs(req.Problems...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Judge.Query().Where(judge.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewJudgeCreate(e), nil
}

// ReadJudge handles GET /judges/{id} requests.
func (h *OgentHandler) ReadJudge(ctx context.Context, params ReadJudgeParams) (ReadJudgeRes, error) {
	q := h.client.Judge.Query().Where(judge.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewJudgeRead(e), nil
}

// UpdateJudge handles PATCH /judges/{id} requests.
func (h *OgentHandler) UpdateJudge(ctx context.Context, req *UpdateJudgeReq, params UpdateJudgeParams) (UpdateJudgeRes, error) {
	b := h.client.Judge.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Code.Get(); ok {
		b.SetCode(v)
	}
	if v, ok := req.Type.Get(); ok {
		b.SetType(judge.Type(v))
	}
	if v, ok := req.Configuration.Get(); ok {
		b.SetConfiguration(v)
	}
	// Add all edges.
	if req.Problems != nil {
		b.ClearProblems().AddProblemIDs(req.Problems...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Judge.Query().Where(judge.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewJudgeUpdate(e), nil
}

// DeleteJudge handles DELETE /judges/{id} requests.
func (h *OgentHandler) DeleteJudge(ctx context.Context, params DeleteJudgeParams) (DeleteJudgeRes, error) {
	err := h.client.Judge.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteJudgeNoContent), nil

}

// ListJudge handles GET /judges requests.
func (h *OgentHandler) ListJudge(ctx context.Context, params ListJudgeParams) (ListJudgeRes, error) {
	q := h.client.Judge.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewJudgeLists(es)
	return (*ListJudgeOKApplicationJSON)(&r), nil
}

// ListJudgeProblems handles GET /judges/{id}/problems requests.
func (h *OgentHandler) ListJudgeProblems(ctx context.Context, params ListJudgeProblemsParams) (ListJudgeProblemsRes, error) {
	q := h.client.Judge.Query().Where(judge.IDEQ(params.ID)).QueryProblems()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewJudgeProblemsLists(es)
	return (*ListJudgeProblemsOKApplicationJSON)(&r), nil
}

// CreateProblem handles POST /problems requests.
func (h *OgentHandler) CreateProblem(ctx context.Context, req *CreateProblemReq) (CreateProblemRes, error) {
	b := h.client.Problem.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	b.SetName(req.Name)
	b.SetCode(req.Code)
	// Add all edges.
	b.AddSubmissionIDs(req.Submissions...)
	b.SetJudgeID(req.Judge)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Problem.Query().Where(problem.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewProblemCreate(e), nil
}

// ReadProblem handles GET /problems/{id} requests.
func (h *OgentHandler) ReadProblem(ctx context.Context, params ReadProblemParams) (ReadProblemRes, error) {
	q := h.client.Problem.Query().Where(problem.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewProblemRead(e), nil
}

// UpdateProblem handles PATCH /problems/{id} requests.
func (h *OgentHandler) UpdateProblem(ctx context.Context, req *UpdateProblemReq, params UpdateProblemParams) (UpdateProblemRes, error) {
	b := h.client.Problem.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Code.Get(); ok {
		b.SetCode(v)
	}
	// Add all edges.
	if req.Submissions != nil {
		b.ClearSubmissions().AddSubmissionIDs(req.Submissions...)
	}
	if v, ok := req.Judge.Get(); ok {
		b.SetJudgeID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Problem.Query().Where(problem.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewProblemUpdate(e), nil
}

// DeleteProblem handles DELETE /problems/{id} requests.
func (h *OgentHandler) DeleteProblem(ctx context.Context, params DeleteProblemParams) (DeleteProblemRes, error) {
	err := h.client.Problem.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteProblemNoContent), nil

}

// ListProblem handles GET /problems requests.
func (h *OgentHandler) ListProblem(ctx context.Context, params ListProblemParams) (ListProblemRes, error) {
	q := h.client.Problem.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewProblemLists(es)
	return (*ListProblemOKApplicationJSON)(&r), nil
}

// ListProblemSubmissions handles GET /problems/{id}/submissions requests.
func (h *OgentHandler) ListProblemSubmissions(ctx context.Context, params ListProblemSubmissionsParams) (ListProblemSubmissionsRes, error) {
	q := h.client.Problem.Query().Where(problem.IDEQ(params.ID)).QuerySubmissions()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewProblemSubmissionsLists(es)
	return (*ListProblemSubmissionsOKApplicationJSON)(&r), nil
}

// ReadProblemJudge handles GET /problems/{id}/judge requests.
func (h *OgentHandler) ReadProblemJudge(ctx context.Context, params ReadProblemJudgeParams) (ReadProblemJudgeRes, error) {
	q := h.client.Problem.Query().Where(problem.IDEQ(params.ID)).QueryJudge()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewProblemJudgeRead(e), nil
}

// CreateSubmission handles POST /submissions requests.
func (h *OgentHandler) CreateSubmission(ctx context.Context, req *CreateSubmissionReq) (CreateSubmissionRes, error) {
	b := h.client.Submission.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	b.SetStatus(submission.Status(req.Status))
	b.SetVerdict(submission.Verdict(req.Verdict))
	b.SetTestCount(req.TestCount)
	// Add all edges.
	b.SetProblemID(req.Problem)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Submission.Query().Where(submission.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewSubmissionCreate(e), nil
}

// ReadSubmission handles GET /submissions/{id} requests.
func (h *OgentHandler) ReadSubmission(ctx context.Context, params ReadSubmissionParams) (ReadSubmissionRes, error) {
	q := h.client.Submission.Query().Where(submission.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewSubmissionRead(e), nil
}

// UpdateSubmission handles PATCH /submissions/{id} requests.
func (h *OgentHandler) UpdateSubmission(ctx context.Context, req *UpdateSubmissionReq, params UpdateSubmissionParams) (UpdateSubmissionRes, error) {
	b := h.client.Submission.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.Status.Get(); ok {
		b.SetStatus(submission.Status(v))
	}
	if v, ok := req.Verdict.Get(); ok {
		b.SetVerdict(submission.Verdict(v))
	}
	if v, ok := req.TestCount.Get(); ok {
		b.SetTestCount(v)
	}
	// Add all edges.
	if v, ok := req.Problem.Get(); ok {
		b.SetProblemID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Submission.Query().Where(submission.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewSubmissionUpdate(e), nil
}

// DeleteSubmission handles DELETE /submissions/{id} requests.
func (h *OgentHandler) DeleteSubmission(ctx context.Context, params DeleteSubmissionParams) (DeleteSubmissionRes, error) {
	err := h.client.Submission.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteSubmissionNoContent), nil

}

// ListSubmission handles GET /submissions requests.
func (h *OgentHandler) ListSubmission(ctx context.Context, params ListSubmissionParams) (ListSubmissionRes, error) {
	q := h.client.Submission.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewSubmissionLists(es)
	return (*ListSubmissionOKApplicationJSON)(&r), nil
}

// ReadSubmissionProblem handles GET /submissions/{id}/problem requests.
func (h *OgentHandler) ReadSubmissionProblem(ctx context.Context, params ReadSubmissionProblemParams) (ReadSubmissionProblemRes, error) {
	q := h.client.Submission.Query().Where(submission.IDEQ(params.ID)).QueryProblem()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewSubmissionProblemRead(e), nil
}
