// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/syoi-org/judy/ent"

func NewJudgeCreate(e *ent.Judge) *JudgeCreate {
	if e == nil {
		return nil
	}
	var ret JudgeCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	ret.Type = JudgeCreateType(e.Type)
	ret.Configuration = e.Configuration
	return &ret
}

func NewJudgeCreates(es []*ent.Judge) []JudgeCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]JudgeCreate, len(es))
	for i, e := range es {
		r[i] = NewJudgeCreate(e).Elem()
	}
	return r
}

func (j *JudgeCreate) Elem() JudgeCreate {
	if j == nil {
		return JudgeCreate{}
	}
	return *j
}

func NewJudgeList(e *ent.Judge) *JudgeList {
	if e == nil {
		return nil
	}
	var ret JudgeList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	ret.Type = JudgeListType(e.Type)
	ret.Configuration = e.Configuration
	return &ret
}

func NewJudgeLists(es []*ent.Judge) []JudgeList {
	if len(es) == 0 {
		return nil
	}
	r := make([]JudgeList, len(es))
	for i, e := range es {
		r[i] = NewJudgeList(e).Elem()
	}
	return r
}

func (j *JudgeList) Elem() JudgeList {
	if j == nil {
		return JudgeList{}
	}
	return *j
}

func NewJudgeRead(e *ent.Judge) *JudgeRead {
	if e == nil {
		return nil
	}
	var ret JudgeRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	ret.Type = JudgeReadType(e.Type)
	ret.Configuration = e.Configuration
	return &ret
}

func NewJudgeReads(es []*ent.Judge) []JudgeRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]JudgeRead, len(es))
	for i, e := range es {
		r[i] = NewJudgeRead(e).Elem()
	}
	return r
}

func (j *JudgeRead) Elem() JudgeRead {
	if j == nil {
		return JudgeRead{}
	}
	return *j
}

func NewJudgeUpdate(e *ent.Judge) *JudgeUpdate {
	if e == nil {
		return nil
	}
	var ret JudgeUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	ret.Type = JudgeUpdateType(e.Type)
	ret.Configuration = e.Configuration
	return &ret
}

func NewJudgeUpdates(es []*ent.Judge) []JudgeUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]JudgeUpdate, len(es))
	for i, e := range es {
		r[i] = NewJudgeUpdate(e).Elem()
	}
	return r
}

func (j *JudgeUpdate) Elem() JudgeUpdate {
	if j == nil {
		return JudgeUpdate{}
	}
	return *j
}

func NewJudgeProblemsList(e *ent.Problem) *JudgeProblemsList {
	if e == nil {
		return nil
	}
	var ret JudgeProblemsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	return &ret
}

func NewJudgeProblemsLists(es []*ent.Problem) []JudgeProblemsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]JudgeProblemsList, len(es))
	for i, e := range es {
		r[i] = NewJudgeProblemsList(e).Elem()
	}
	return r
}

func (pr *JudgeProblemsList) Elem() JudgeProblemsList {
	if pr == nil {
		return JudgeProblemsList{}
	}
	return *pr
}

func NewProblemCreate(e *ent.Problem) *ProblemCreate {
	if e == nil {
		return nil
	}
	var ret ProblemCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	return &ret
}

func NewProblemCreates(es []*ent.Problem) []ProblemCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ProblemCreate, len(es))
	for i, e := range es {
		r[i] = NewProblemCreate(e).Elem()
	}
	return r
}

func (pr *ProblemCreate) Elem() ProblemCreate {
	if pr == nil {
		return ProblemCreate{}
	}
	return *pr
}

func NewProblemList(e *ent.Problem) *ProblemList {
	if e == nil {
		return nil
	}
	var ret ProblemList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	return &ret
}

func NewProblemLists(es []*ent.Problem) []ProblemList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ProblemList, len(es))
	for i, e := range es {
		r[i] = NewProblemList(e).Elem()
	}
	return r
}

func (pr *ProblemList) Elem() ProblemList {
	if pr == nil {
		return ProblemList{}
	}
	return *pr
}

func NewProblemRead(e *ent.Problem) *ProblemRead {
	if e == nil {
		return nil
	}
	var ret ProblemRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	return &ret
}

func NewProblemReads(es []*ent.Problem) []ProblemRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ProblemRead, len(es))
	for i, e := range es {
		r[i] = NewProblemRead(e).Elem()
	}
	return r
}

func (pr *ProblemRead) Elem() ProblemRead {
	if pr == nil {
		return ProblemRead{}
	}
	return *pr
}

func NewProblemUpdate(e *ent.Problem) *ProblemUpdate {
	if e == nil {
		return nil
	}
	var ret ProblemUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	return &ret
}

func NewProblemUpdates(es []*ent.Problem) []ProblemUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ProblemUpdate, len(es))
	for i, e := range es {
		r[i] = NewProblemUpdate(e).Elem()
	}
	return r
}

func (pr *ProblemUpdate) Elem() ProblemUpdate {
	if pr == nil {
		return ProblemUpdate{}
	}
	return *pr
}

func NewProblemJudgeRead(e *ent.Judge) *ProblemJudgeRead {
	if e == nil {
		return nil
	}
	var ret ProblemJudgeRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	ret.Type = ProblemJudgeReadType(e.Type)
	ret.Configuration = e.Configuration
	return &ret
}

func NewProblemJudgeReads(es []*ent.Judge) []ProblemJudgeRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ProblemJudgeRead, len(es))
	for i, e := range es {
		r[i] = NewProblemJudgeRead(e).Elem()
	}
	return r
}

func (j *ProblemJudgeRead) Elem() ProblemJudgeRead {
	if j == nil {
		return ProblemJudgeRead{}
	}
	return *j
}

func NewProblemSubmissionsList(e *ent.Submission) *ProblemSubmissionsList {
	if e == nil {
		return nil
	}
	var ret ProblemSubmissionsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Status = ProblemSubmissionsListStatus(e.Status)
	ret.Verdict = ProblemSubmissionsListVerdict(e.Verdict)
	ret.TestCount = e.TestCount
	return &ret
}

func NewProblemSubmissionsLists(es []*ent.Submission) []ProblemSubmissionsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ProblemSubmissionsList, len(es))
	for i, e := range es {
		r[i] = NewProblemSubmissionsList(e).Elem()
	}
	return r
}

func (s *ProblemSubmissionsList) Elem() ProblemSubmissionsList {
	if s == nil {
		return ProblemSubmissionsList{}
	}
	return *s
}

func NewSubmissionCreate(e *ent.Submission) *SubmissionCreate {
	if e == nil {
		return nil
	}
	var ret SubmissionCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Status = SubmissionCreateStatus(e.Status)
	ret.Verdict = SubmissionCreateVerdict(e.Verdict)
	ret.TestCount = e.TestCount
	return &ret
}

func NewSubmissionCreates(es []*ent.Submission) []SubmissionCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SubmissionCreate, len(es))
	for i, e := range es {
		r[i] = NewSubmissionCreate(e).Elem()
	}
	return r
}

func (s *SubmissionCreate) Elem() SubmissionCreate {
	if s == nil {
		return SubmissionCreate{}
	}
	return *s
}

func NewSubmissionList(e *ent.Submission) *SubmissionList {
	if e == nil {
		return nil
	}
	var ret SubmissionList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Status = SubmissionListStatus(e.Status)
	ret.Verdict = SubmissionListVerdict(e.Verdict)
	ret.TestCount = e.TestCount
	return &ret
}

func NewSubmissionLists(es []*ent.Submission) []SubmissionList {
	if len(es) == 0 {
		return nil
	}
	r := make([]SubmissionList, len(es))
	for i, e := range es {
		r[i] = NewSubmissionList(e).Elem()
	}
	return r
}

func (s *SubmissionList) Elem() SubmissionList {
	if s == nil {
		return SubmissionList{}
	}
	return *s
}

func NewSubmissionRead(e *ent.Submission) *SubmissionRead {
	if e == nil {
		return nil
	}
	var ret SubmissionRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Status = SubmissionReadStatus(e.Status)
	ret.Verdict = SubmissionReadVerdict(e.Verdict)
	ret.TestCount = e.TestCount
	return &ret
}

func NewSubmissionReads(es []*ent.Submission) []SubmissionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SubmissionRead, len(es))
	for i, e := range es {
		r[i] = NewSubmissionRead(e).Elem()
	}
	return r
}

func (s *SubmissionRead) Elem() SubmissionRead {
	if s == nil {
		return SubmissionRead{}
	}
	return *s
}

func NewSubmissionUpdate(e *ent.Submission) *SubmissionUpdate {
	if e == nil {
		return nil
	}
	var ret SubmissionUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Status = SubmissionUpdateStatus(e.Status)
	ret.Verdict = SubmissionUpdateVerdict(e.Verdict)
	ret.TestCount = e.TestCount
	return &ret
}

func NewSubmissionUpdates(es []*ent.Submission) []SubmissionUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SubmissionUpdate, len(es))
	for i, e := range es {
		r[i] = NewSubmissionUpdate(e).Elem()
	}
	return r
}

func (s *SubmissionUpdate) Elem() SubmissionUpdate {
	if s == nil {
		return SubmissionUpdate{}
	}
	return *s
}

func NewSubmissionProblemRead(e *ent.Problem) *SubmissionProblemRead {
	if e == nil {
		return nil
	}
	var ret SubmissionProblemRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.Name = e.Name
	ret.Code = e.Code
	return &ret
}

func NewSubmissionProblemReads(es []*ent.Problem) []SubmissionProblemRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SubmissionProblemRead, len(es))
	for i, e := range es {
		r[i] = NewSubmissionProblemRead(e).Elem()
	}
	return r
}

func (pr *SubmissionProblemRead) Elem() SubmissionProblemRead {
	if pr == nil {
		return SubmissionProblemRead{}
	}
	return *pr
}
