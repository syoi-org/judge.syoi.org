// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/syoi-org/judy/ent"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Judge struct {
		Code          func(childComplexity int) int
		Configuration func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Problems      func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	JudgeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	JudgeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateJudge      func(childComplexity int, input ent.CreateJudgeInput) int
		CreateProblem    func(childComplexity int, input ent.CreateProblemInput) int
		CreateSubmission func(childComplexity int, input ent.CreateSubmissionInput) int
		UpdateJudge      func(childComplexity int, id int, input ent.UpdateJudgeInput) int
		UpdateProblem    func(childComplexity int, id int, input ent.UpdateProblemInput) int
		UpdateSubmission func(childComplexity int, id int, input ent.UpdateSubmissionInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Problem struct {
		Code        func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Judge       func(childComplexity int) int
		Name        func(childComplexity int) int
		Submissions func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int) int
		UpdatedAt   func(childComplexity int) int
	}

	ProblemConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProblemEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		Judges      func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int) int
		Node        func(childComplexity int, id int) int
		Nodes       func(childComplexity int, ids []int) int
		Problems    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int) int
		Submissions func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int) int
	}

	Submission struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Problem   func(childComplexity int) int
		Status    func(childComplexity int) int
		TestCount func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		Verdict   func(childComplexity int) int
	}

	SubmissionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SubmissionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Judge.code":
		if e.complexity.Judge.Code == nil {
			break
		}

		return e.complexity.Judge.Code(childComplexity), true

	case "Judge.configuration":
		if e.complexity.Judge.Configuration == nil {
			break
		}

		return e.complexity.Judge.Configuration(childComplexity), true

	case "Judge.createdAt":
		if e.complexity.Judge.CreatedAt == nil {
			break
		}

		return e.complexity.Judge.CreatedAt(childComplexity), true

	case "Judge.id":
		if e.complexity.Judge.ID == nil {
			break
		}

		return e.complexity.Judge.ID(childComplexity), true

	case "Judge.name":
		if e.complexity.Judge.Name == nil {
			break
		}

		return e.complexity.Judge.Name(childComplexity), true

	case "Judge.problems":
		if e.complexity.Judge.Problems == nil {
			break
		}

		args, err := ec.field_Judge_problems_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Judge.Problems(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int)), true

	case "Judge.type":
		if e.complexity.Judge.Type == nil {
			break
		}

		return e.complexity.Judge.Type(childComplexity), true

	case "Judge.updatedAt":
		if e.complexity.Judge.UpdatedAt == nil {
			break
		}

		return e.complexity.Judge.UpdatedAt(childComplexity), true

	case "JudgeConnection.edges":
		if e.complexity.JudgeConnection.Edges == nil {
			break
		}

		return e.complexity.JudgeConnection.Edges(childComplexity), true

	case "JudgeConnection.pageInfo":
		if e.complexity.JudgeConnection.PageInfo == nil {
			break
		}

		return e.complexity.JudgeConnection.PageInfo(childComplexity), true

	case "JudgeConnection.totalCount":
		if e.complexity.JudgeConnection.TotalCount == nil {
			break
		}

		return e.complexity.JudgeConnection.TotalCount(childComplexity), true

	case "JudgeEdge.cursor":
		if e.complexity.JudgeEdge.Cursor == nil {
			break
		}

		return e.complexity.JudgeEdge.Cursor(childComplexity), true

	case "JudgeEdge.node":
		if e.complexity.JudgeEdge.Node == nil {
			break
		}

		return e.complexity.JudgeEdge.Node(childComplexity), true

	case "Mutation.createJudge":
		if e.complexity.Mutation.CreateJudge == nil {
			break
		}

		args, err := ec.field_Mutation_createJudge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateJudge(childComplexity, args["input"].(ent.CreateJudgeInput)), true

	case "Mutation.createProblem":
		if e.complexity.Mutation.CreateProblem == nil {
			break
		}

		args, err := ec.field_Mutation_createProblem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProblem(childComplexity, args["input"].(ent.CreateProblemInput)), true

	case "Mutation.createSubmission":
		if e.complexity.Mutation.CreateSubmission == nil {
			break
		}

		args, err := ec.field_Mutation_createSubmission_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSubmission(childComplexity, args["input"].(ent.CreateSubmissionInput)), true

	case "Mutation.updateJudge":
		if e.complexity.Mutation.UpdateJudge == nil {
			break
		}

		args, err := ec.field_Mutation_updateJudge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateJudge(childComplexity, args["id"].(int), args["input"].(ent.UpdateJudgeInput)), true

	case "Mutation.updateProblem":
		if e.complexity.Mutation.UpdateProblem == nil {
			break
		}

		args, err := ec.field_Mutation_updateProblem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProblem(childComplexity, args["id"].(int), args["input"].(ent.UpdateProblemInput)), true

	case "Mutation.updateSubmission":
		if e.complexity.Mutation.UpdateSubmission == nil {
			break
		}

		args, err := ec.field_Mutation_updateSubmission_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSubmission(childComplexity, args["id"].(int), args["input"].(ent.UpdateSubmissionInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Problem.code":
		if e.complexity.Problem.Code == nil {
			break
		}

		return e.complexity.Problem.Code(childComplexity), true

	case "Problem.createdAt":
		if e.complexity.Problem.CreatedAt == nil {
			break
		}

		return e.complexity.Problem.CreatedAt(childComplexity), true

	case "Problem.id":
		if e.complexity.Problem.ID == nil {
			break
		}

		return e.complexity.Problem.ID(childComplexity), true

	case "Problem.judge":
		if e.complexity.Problem.Judge == nil {
			break
		}

		return e.complexity.Problem.Judge(childComplexity), true

	case "Problem.name":
		if e.complexity.Problem.Name == nil {
			break
		}

		return e.complexity.Problem.Name(childComplexity), true

	case "Problem.submissions":
		if e.complexity.Problem.Submissions == nil {
			break
		}

		args, err := ec.field_Problem_submissions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Problem.Submissions(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int)), true

	case "Problem.updatedAt":
		if e.complexity.Problem.UpdatedAt == nil {
			break
		}

		return e.complexity.Problem.UpdatedAt(childComplexity), true

	case "ProblemConnection.edges":
		if e.complexity.ProblemConnection.Edges == nil {
			break
		}

		return e.complexity.ProblemConnection.Edges(childComplexity), true

	case "ProblemConnection.pageInfo":
		if e.complexity.ProblemConnection.PageInfo == nil {
			break
		}

		return e.complexity.ProblemConnection.PageInfo(childComplexity), true

	case "ProblemConnection.totalCount":
		if e.complexity.ProblemConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProblemConnection.TotalCount(childComplexity), true

	case "ProblemEdge.cursor":
		if e.complexity.ProblemEdge.Cursor == nil {
			break
		}

		return e.complexity.ProblemEdge.Cursor(childComplexity), true

	case "ProblemEdge.node":
		if e.complexity.ProblemEdge.Node == nil {
			break
		}

		return e.complexity.ProblemEdge.Node(childComplexity), true

	case "Query.judges":
		if e.complexity.Query.Judges == nil {
			break
		}

		args, err := ec.field_Query_judges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Judges(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.problems":
		if e.complexity.Query.Problems == nil {
			break
		}

		args, err := ec.field_Query_problems_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Problems(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int)), true

	case "Query.submissions":
		if e.complexity.Query.Submissions == nil {
			break
		}

		args, err := ec.field_Query_submissions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Submissions(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int)), true

	case "Submission.createdAt":
		if e.complexity.Submission.CreatedAt == nil {
			break
		}

		return e.complexity.Submission.CreatedAt(childComplexity), true

	case "Submission.id":
		if e.complexity.Submission.ID == nil {
			break
		}

		return e.complexity.Submission.ID(childComplexity), true

	case "Submission.problem":
		if e.complexity.Submission.Problem == nil {
			break
		}

		return e.complexity.Submission.Problem(childComplexity), true

	case "Submission.status":
		if e.complexity.Submission.Status == nil {
			break
		}

		return e.complexity.Submission.Status(childComplexity), true

	case "Submission.testCount":
		if e.complexity.Submission.TestCount == nil {
			break
		}

		return e.complexity.Submission.TestCount(childComplexity), true

	case "Submission.updatedAt":
		if e.complexity.Submission.UpdatedAt == nil {
			break
		}

		return e.complexity.Submission.UpdatedAt(childComplexity), true

	case "Submission.verdict":
		if e.complexity.Submission.Verdict == nil {
			break
		}

		return e.complexity.Submission.Verdict(childComplexity), true

	case "SubmissionConnection.edges":
		if e.complexity.SubmissionConnection.Edges == nil {
			break
		}

		return e.complexity.SubmissionConnection.Edges(childComplexity), true

	case "SubmissionConnection.pageInfo":
		if e.complexity.SubmissionConnection.PageInfo == nil {
			break
		}

		return e.complexity.SubmissionConnection.PageInfo(childComplexity), true

	case "SubmissionConnection.totalCount":
		if e.complexity.SubmissionConnection.TotalCount == nil {
			break
		}

		return e.complexity.SubmissionConnection.TotalCount(childComplexity), true

	case "SubmissionEdge.cursor":
		if e.complexity.SubmissionEdge.Cursor == nil {
			break
		}

		return e.complexity.SubmissionEdge.Cursor(childComplexity), true

	case "SubmissionEdge.node":
		if e.complexity.SubmissionEdge.Node == nil {
			break
		}

		return e.complexity.SubmissionEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateJudgeInput,
		ec.unmarshalInputCreateProblemInput,
		ec.unmarshalInputCreateSubmissionInput,
		ec.unmarshalInputUpdateJudgeInput,
		ec.unmarshalInputUpdateProblemInput,
		ec.unmarshalInputUpdateSubmissionInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateJudgeInput is used for create Judge object.
Input was generated by ent.
"""
input CreateJudgeInput {
  createdAt: Time
  updatedAt: Time
  name: String!
  code: String!
  type: JudgeType
  configuration: String!
  problemIDs: [ID!]
}
"""
CreateProblemInput is used for create Problem object.
Input was generated by ent.
"""
input CreateProblemInput {
  createdAt: Time
  updatedAt: Time
  name: String!
  code: String!
  submissionIDs: [ID!]
  judgeID: ID!
}
"""
CreateSubmissionInput is used for create Submission object.
Input was generated by ent.
"""
input CreateSubmissionInput {
  createdAt: Time
  updatedAt: Time
  status: SubmissionStatus
  verdict: SubmissionVerdict
  testCount: Int
  problemID: ID!
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Judge implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  code: String!
  type: JudgeType!
  configuration: String!
  problems(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int
  ): ProblemConnection!
}
"""
A connection to a list of items.
"""
type JudgeConnection {
  """
  A list of edges.
  """
  edges: [JudgeEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type JudgeEdge {
  """
  The item at the end of the edge.
  """
  node: Judge
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
JudgeType is enum for the field type
"""
enum JudgeType @goModel(model: "github.com/syoi-org/judy/ent/judge.Type") {
  local
  codeforces
  vjudge
  syoj
  noop
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/syoi-org/judy/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Problem implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  code: String!
  submissions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int
  ): SubmissionConnection!
  judge: Judge!
}
"""
A connection to a list of items.
"""
type ProblemConnection {
  """
  A list of edges.
  """
  edges: [ProblemEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ProblemEdge {
  """
  The item at the end of the edge.
  """
  node: Problem
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  judges(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int
  ): JudgeConnection!
  problems(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int
  ): ProblemConnection!
  submissions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int
  ): SubmissionConnection!
}
type Submission implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  status: SubmissionStatus!
  verdict: SubmissionVerdict!
  testCount: Int!
  problem: Problem!
}
"""
A connection to a list of items.
"""
type SubmissionConnection {
  """
  A list of edges.
  """
  edges: [SubmissionEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type SubmissionEdge {
  """
  The item at the end of the edge.
  """
  node: Submission
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
SubmissionStatus is enum for the field status
"""
enum SubmissionStatus @goModel(model: "github.com/syoi-org/judy/ent/submission.Status") {
  pending
  compiling
  judging
  finished
}
"""
SubmissionVerdict is enum for the field verdict
"""
enum SubmissionVerdict @goModel(model: "github.com/syoi-org/judy/ent/submission.Verdict") {
  OK
  TLE
  MLE
  ILE
  WA
  CE
  RE
  PE
  CRASHED
  OTHER
}
"""
The builtin Time type
"""
scalar Time
"""
UpdateJudgeInput is used for update Judge object.
Input was generated by ent.
"""
input UpdateJudgeInput {
  createdAt: Time
  updatedAt: Time
  name: String
  code: String
  type: JudgeType
  configuration: String
  addProblemIDs: [ID!]
  removeProblemIDs: [ID!]
  clearProblems: Boolean
}
"""
UpdateProblemInput is used for update Problem object.
Input was generated by ent.
"""
input UpdateProblemInput {
  createdAt: Time
  updatedAt: Time
  name: String
  code: String
  addSubmissionIDs: [ID!]
  removeSubmissionIDs: [ID!]
  clearSubmissions: Boolean
  judgeID: ID
}
"""
UpdateSubmissionInput is used for update Submission object.
Input was generated by ent.
"""
input UpdateSubmissionInput {
  createdAt: Time
  updatedAt: Time
  status: SubmissionStatus
  verdict: SubmissionVerdict
  testCount: Int
  problemID: ID
}
`, BuiltIn: false},
	{Name: "../../mutation.graphql", Input: `type Mutation {
    createJudge(input: CreateJudgeInput!): Judge!
    updateJudge(id: ID!, input: UpdateJudgeInput!): Judge!
    createProblem(input: CreateProblemInput!): Problem!
    updateProblem(id: ID!, input: UpdateProblemInput!): Problem!
    createSubmission(input: CreateSubmissionInput!): Submission!
    updateSubmission(id: ID!, input: UpdateSubmissionInput!): Submission!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
